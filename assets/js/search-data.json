{
  
  "0": {
    "title": "Implementing a binding",
    "content": "Implementing a binding . If you’re implementing a binding, the only runtime dependency you may have on this library may be the RelaynetError class, which you may want to extend for consistency with this library and to be able to use VError. . You may also use other elements exposed by this library in your tests – Mostly likely Parcel, generateRSAKeyPair and issueNodeCertificate. . Everything else is likely to be unique to the binding you’re implementing. . If you want to see what a binding implementation in Node.js looks like, have a look at @relaycorp/relaynet-pohttp. .",
    "url": "/relaynet-core-js/howto-binding.html",
    "relUrl": "/howto-binding.html"
  }
  ,"1": {
    "title": "Implementing a courier",
    "content": "Implementing a courier . TODO: Write up after implementing https://github.com/relaycorp/relaynet-courier so we can reuse code snippets .",
    "url": "/relaynet-core-js/howto-courier.html",
    "relUrl": "/howto-courier.html"
  }
  ,"2": {
    "title": "Implementing a gateway",
    "content": "Implementing a gateway . TODO: Write up after implementing https://github.com/relaycorp/relaynet-gateway-desktop and/or https://github.com/relaycorp/relaynet-internet-gateway so we can reuse code snippets .",
    "url": "/relaynet-core-js/howto-gateway.html",
    "relUrl": "/howto-gateway.html"
  }
  ,"3": {
    "title": "Implementing a service",
    "content": "Implementing a service . A Relaynet service is a collection of applications that communicate amongst themselves in a centralized or decentralized manner. As a Relaynet app developer, you can use this library to send and receive messages serialized in any format (e.g., JSON, ProtocolBuffers) without being concerned about the underlying transport method(s) (e.g., sneakernet, Tor). . If you’re unfamiliar with the terminology used in Relaynet, you should start by reading the introduction and the concepts sections from the core specification to get a high-level understanding of the technology. . Generating endpoint key pair . Before you’re able to send or receive parcels, you have to initialize your endpoint by generating an RSA key pair with generateRSAKeyPair() and getting the public key certified: . import { generateRSAKeyPair, issueNodeCertificate, } from &#39;@relaycorp/relaynet-core&#39;; async function initEndpoint() { const { privateKey, publicKey } = await generateRSAKeyPair(); yourFunctionToSecurelyPersistPrivateKey(privateKey); // Self-signing certificate here, but it can/should be issued by the gateway const certificate = await issueNodeCertificate({ issuerPrivateKey: privateKey, subjectPublicKey: publicKey, }); yourFunctionToShareCertificate(certificate); } . The private address of your endpoint will be derived from its public key, so depending on the nature of your service you may want to repeat the process above with each endpoint that you communicate with in order to avoid fingerprinting. . Exchanging messages . As shown in the diagram below, each message between two applications is encapsulated as a parcel, so sending and receiving messages involves serializing and deserializing parcels: . . For example, consider a centralized service whose applications exchange JSON messages such as the one below: . { &quot;message&quot;: &quot;Hello world&quot; } . That message could be serialized as a parcel as follows: . import { Parcel, ServiceMessage } from &#39;@relaycorp/relaynet-core&#39;; async function serializeMessage() { const serviceMessage = new ServiceMessage( &#39;application/vdn+acme.message+json&#39;, Buffer.from(JSON.stringify({ message: &#39;Hello world&#39; })), ); const parcel = new Parcel( &#39;rne+https://acme.com&#39;, senderCertificate, serviceMessage.serialize(), ); return await parcel.serialize(senderPrivateKey, recipientCertificate); } . On the other hand, incoming messages could be deserialized (plus verified and decrypted) as follows: . import { Parcel } from &#39;@relaycorp/relaynet-core&#39;; async function deserializeParcel(parcelSerialized) { const parcel = await Parcel.deserialize(parcelSerialized); // At this point the sender&#39;s signature has been verified console.log(&#39;Received parcel from&#39;, parcel.senderCertificate.getCommonName()); if (parcel.recipient !== &#39;rne+https://acme.com&#39;) { throw new Error(&#39;Invalid recipient&#39;); } return await parcel.unwrapMessage(recipientPrivateKey); } . With the Channel Session Protocol . Where possible, you should use the channel session protocol to exchange messages because that adds perfect forward secrecy, future secrecy and replay attack mitigation. This library hides nearly all the technical details of the protocol, but you’re still responsible for securely persisting and retrieving the ephemeral keys until they expire. . This protocol requires the recipient to generate an ephemeral key pair and share the public component before communication begins, in addition to the longer term key already generated above; e.g.: . import { issueInitialDHKeyCertificate, generateECDHKeyPair, } from &#39;@relaycorp/relaynet-core&#39;; async function generateInitialKeyPair() { const { privateKey, publicKey } = await generateECDHKeyPair(); yourFunctionToSecurelyPersistSessionPrivateKey(privateKey); // Self-signing certificate here, but it can/should be issued by the gateway const endpointPrivateKey = yourFunctionToSecurelyRetrievePrivateKey(); const endpointCertificate = yourFunctionToRetrieveCertificate(); const certificate = await issueInitialDHKeyCertificate({ issuerPrivateKey: endpointPrivateKey, issuerCertificate: endpointCertificate, subjectPublicKey: publicKey, }); yourFunctionToShareInitialCertificate(certificate); } . Then the examples above to serialize and deserialize parcels can be rewritten as follows: . import { Parcel, ServiceMessage } from &#39;@relaycorp/relaynet-core&#39;; async function serializeMessage() { const serviceMessage = new ServiceMessage( &#39;application/vdn+acme.message+json&#39;, Buffer.from(JSON.stringify({ message: &#39;Hello world&#39; })), ); const parcel = new Parcel( &#39;rne+https://acme.com&#39;, senderCertificate, serviceMessage.serialize(), ); const { serialization, dhPrivateKey } = await parcel.serializeWithSession( senderPrivateKey, recipientDhCertificate, ); yourFunctionToSecurelyPersistSessionPrivateKey(dhPrivateKey); return serialization; } async function deserializeParcel(parcelSerialized) { const parcel = await Parcel.deserialize(parcelSerialized); // At this point the sender&#39;s signature has been verified console.log(&#39;Received parcel from&#39;, parcel.senderCertificate.getCommonName()); if (parcel.recipient !== &#39;rne+https://acme.com&#39;) { throw new Error(&#39;Invalid recipient&#39;); } return await parcel.unwrapMessageWithSession( recipientDhPrivateKey, recipientDhCertificate, ); } .",
    "url": "/relaynet-core-js/howto-service.html",
    "relUrl": "/howto-service.html"
  }
  ,"4": {
    "title": "Relaynet SDK",
    "content": "Relaynet SDK . This library implements the core of Relaynet and is meant to be used by anyone using the network from a Node.js application. . Please note that this documentation is mostly incomplete because the interface exposed by this library is changing rapidly as of this writing. Also note that the examples in this documentation won’t work until a gateway (e.g., the desktop one) has been implemented. We expect the library to reach a stable status and its documentation to be completed by the end of Q3 2020. . Install . @relaycorp/relaynet-core requires Node.js v10 or newer, and the latest stable release can be installed as follows: . npm install --save @relaycorp/relaynet-core . Development releases use the dev tag (@relaycorp/relaynet-core@dev). . Use . This library can be used for different purposes, so please refer to the documentation for your specific use case: . Most people will be interested in adding Relaynet support to their app, whether the app is pre-existing or is being built from scratch. . Relaycorp provides implementations for gateways, couriers and bindings, so if you’re contributing to those implementations or for whatever reason you’d like to build your own, please refer to the follow documents: . Implementing a binding. | Implementing a gateway. | Implementing a courier. | . TypeScript type declarations are included with this library. Read API documentation. . Specs supported . This library supports the following Relaynet specs: . RS-000 (Relaynet Core). | RS-001 (RAMF v1). | RS-002 (Relaynet PKI). | RS-003 (Relaynet Channel Session Protocol). | RS-018 (Relaynet Cryptographic Algorithms, Version 1). In addition to the required algorithms, the following are also supported: Hashing functions: SHA-384 and SHA-512. | Ciphers: AES-192 and AES-256. | ECDH curves: P-384 and P-521. | . | . Support . If you have any questions or comments, you can find us on Gitter or create an issue on the GitHub project. . Updates . Releases are automatically published on GitHub and NPM, and the changelog can be found on GitHub. This project uses semantic versioning. .",
    "url": "/relaynet-core-js/",
    "relUrl": "/"
  }
  
}